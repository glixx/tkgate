#   Copyright (C) 1987-2004 by Jeffery P. Hansen
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# Last edit by hansen on Fri Sep  8 15:24:56 2006
#

set pd_isfile 1
set pd_file ""
set pd_traceFile ""
set pd_select all
set pd_oldSelect all
set pd_ok 0
set pd_selectList {}
set pd_epsf 0

set pd_inclib 0
set pd_encoding Latin1

set prs_start 0
set prs_end 0
set prs_isFull 0
set prs_range {0 0 0}
set prs_scale 1

set pd_filter ".ps"
set pd_filetypes {
    {{PostScript}	{.ps}}
    {{All Files}	*}
}

#
# Notice changes of the current file
#
trace variable tkg_currentFile w PrintDlg::fileChangeNotify


trace variable longPrinterName w PrintDlg::mapLPNChange


#############################################################################
#Some other common paper sizes not in the table below (in mm):
#Chu ban			220 x 288
#Ko bosho	    		330 x 470
#Mino, Hosokawa, Hodomura	330 x 850
#Mino ban, Hodomura ban 	610 x 860
#Naka bosho 			364 x 500
#O bosho 			394 x 530
#O biro bosho 			440 x 576
#Takenaga bosho 		515 x 757
#Mutsugiri 			203 x 254
#Yatsugiri (hele plaat) 	165 x 216
#Yotsugiri 			254 x 305
#Briefkaart (officieel) 	100 x 148
#Kiku 4 (boeken) 		227 x 306
#Kiku 5 (boeken) 		151 x 227
#Meishi (visitekaartje) 	55 x 91
#############################################################################



#############################################################################
#
# Desription of paper sizes that we support.
#
# The following variables are used for each of the columns respectively.
#    pd_printPgSize
#    pd_printPgSizeName
#
set paperSizeTable {
  {Letter	"Letter (8 1/2 x 11 in.)"	215	279}
  {Legal	"Legal (8 1/2 x 14 in.)"	215	355}
  {Tabloid	"Tabloid (11 x 17 in.)"		279	431}
  {Executive	"Executive (7 1/2 x 10 in.)"	190	254}
  {A4		"A4 (210 x 297 mm)"		210	297}
  {A3		"A3 (297 x 420 mm)"		297	420}
  {A2		"A2 (420 x 594 mm)"		420	594}
  {A1		"A1 (594 x 841 mm)"		594	841}
  {B5		"B5 (176 x 250 mm)"		176	250}
  {B4		"B4 (250 x 353 mm)"		250	353}
  {B3		"B3 (353 x 500 mm)"		353	500}
  {B2		"B2 (500 x 707 mm)"		500	707}
  {SRA2		"SRA2 (450 x 640 mm)"		450	640}
  {RA2		"RA2 (430 x 610 mm)"		430	610}
  {yatsugiri	"yatsugiri (6.5 x 8.5 in)"	165	215}
  {mutsugiri	"mutsugiri (8 x 10 in)"		203	254}
  {yotsugiri	"yotsugiri (10 x 12 in)"	254	304}
}

#############################################################################
#
# Convert a long name to a basic name. (e.g. "Letter (8 1/2 x 11 in.)" to "Letter").
# We do this without the paper size table
#
proc paperNameToSize {name} {
  if { [scan $name %s size] == 1 } {
    return $size
  } else {
    return Letter
  }
}

#############################################################################
#
# Convert a basic name (e.g., "A4") to the long name
#
proc paperSizeToName {name} {
  global paperSizeTable

  foreach s $paperSizeTable {
    if { $name == [lindex $s 0] } {
      return [lindex $s 1]
    }
  }
  return [lindex [lindex $paperSizeTable 0] 1]
}

#############################################################################
#
# Lookup a paper size from a basic name (e.g., "A4")
#
proc paperSizeLookup {name} {
  global paperSizeTable

  foreach s $paperSizeTable {
    if { $name == [lindex $s 0] } {
      return $s
    }
  }
  return {}
}

proc tkg_retrSelMods {w} {
  global pd_select pd_selectList

  set pd_selectList {}
  if { $pd_select == "sel" } {
    foreach m [$w.mods.lb curselection] {
      lappend pd_selectList [$w.mods.lb get $m]
    }
  }
}

proc tkg_prntEPSF {} {
  global pd_epsf pd_isfile pd_select pd_oldSelect

  set w .prntdlg

  catch {
    set w1 .prntdlg.right.mod
    set w2 .prntdlg.right.style

    if { $pd_epsf && $pd_isfile } {
      TabBox::disabletab $w.main.tab Page
      TabBox::disabletab $w.main.tab Content

      $w1.sel.all configure -foreground dimgray -state disabled
      $w1.sel.cur configure -foreground dimgray -state disabled
      $w1.sel.use configure -foreground dimgray -state disabled
      $w1.sel.sel configure -foreground dimgray -state disabled
      $w1.mods.lb configure -foreground dimgray -selectforeground dimgray
      $w1.lib     configure -foreground dimgray -state disabled
      $w2.idx     configure -foreground dimgray -state disabled
      $w2.graph   configure -foreground dimgray -state disabled
      $w2.mrgsml  configure -foreground dimgray -state disabled
      $w2.part.scale   configure -foreground dimgray -state disabled
      $w2.part.multi   configure -foreground dimgray -state disabled
      $w2.l   configure -foreground dimgray
      #	$w1.l   configure -foreground dimgray

      set pd_oldSelect $pd_select
      set pd_select cur

    } {
      TabBox::enabletab $w.main.tab Page
      TabBox::enabletab $w.main.tab Content

      $w1.sel.all configure -foreground black -state normal
      $w1.sel.cur configure -foreground black -state normal
      $w1.sel.use configure -foreground black -state normal
      $w1.sel.sel configure -foreground black -state normal
      $w1.mods.lb configure -foreground black -selectforeground black
      $w1.lib     configure -foreground black -state normal
      $w2.idx     configure -foreground black -state normal
      $w2.graph   configure -foreground black -state normal
      $w2.mrgsml  configure -foreground black -state normal
      $w2.part.scale   configure -foreground black -state normal
      $w2.part.multi   configure -foreground black -state normal
      $w2.l   configure -foreground black
      #	$w1.l   configure -foreground black

      set pd_select $pd_oldSelect

    }
  }
}

#
# Called when the module select mode is pressed
#
proc tkg_prntModuleMode {w} {
  global pd_select
   
  if { $pd_select == "sel" } {
    $w.mods.lb configure -foreground black -selectforeground black
  } else {
    $w.mods.lb configure -foreground dimgray -selectforeground dimgray
  }
}

#############################################################################
#
# Update page example based on current settings
#
proc prntUpdateExample {w} {
  global opts_printPgSize opts_printPgOrient opts_prntDuplex

  $w delete all

  set size [paperSizeLookup $opts_printPgSize]

  set W [expr [lindex $size 2]/10]
  set H [expr [lindex $size 3]/10]

  if { $opts_printPgOrient == "landscape" } {
    set t $W
    set W $H
    set H $t
  }

  $w create rectangle [expr 50 - $W/2]  [expr 50 - $H/2] [expr 50 + $W/2]  [expr 50 + $H/2] \
      -outline black -fill white
}

#############################################################################
#
# Get the command for printing on the specified printer
#
proc getPrintCommand {args} {
  global tkg_printDefCmdTmp tkg_printCmdTmp
  global opts_printer opts_printCommands

  #
  # Get name of requested printer
  #
  if { [llength $args] == 0 } {
    set name $opts_printer
  } else {
    set name [lindex $args 0]
  }

  set cmd [assoc $name $opts_printCommands]

  if { $cmd == "" || [llength $cmd] == 0 } {
    if { $opts_printer == "default" } {
      set PRINTER $name
      set printer $name
      set cmd [subst $tkg_printDefCmdTmp]
    } else {
      set PRINTER $name
      set printer $name
      set cmd [subst $tkg_printCmdTmp]
    }
  }

  return $cmd
}

#############################################################################
#
# Print a file with default values
#
proc tkg_printWithDefaults {isFile name} {
  global pd_isfile pd_file pd_ok
  global tkg_currentFile tkg_displayFile pd_printPgSize
  global pd_file pd_paper pd_printPgOrient pd_printStyle pd_select pd_selectList
  global pd_epsf pd_printIndex pd_printMergeSmall pd_printDuplex pd_inclib pd_printGraph pd_encoding

  Option::dialogLoad -optclass Print
  Option::dialogSave -optclass Print -prefix pd

  set p [string last "/" $pd_file]
  if { $p >= 0 } { set pd_file [string range $pd_file [expr $p + 1] end]}


  if {$isFile} {
    gat_print -file $name -paper $pd_printPgSize -orient $pd_printPgOrient -style $pd_printStyle \
	-select $pd_select -modlist $pd_selectList -epsf $pd_epsf -index $pd_printIndex \
	-merge $pd_printMergeSmall -duplex $pd_printDuplex -graph $pd_printGraph \
	-inclib $pd_inclib -encoding $pd_encoding
  } { 
    set printer [getPrintCommand $name]

    gat_print -printer $printer -paper $pd_printPgSize -orient $pd_printPgOrient -style $pd_printStyle \
	-select $pd_select -modlist $pd_selectList -epsf $pd_epsf -index $pd_printIndex \
	-merge $pd_printMergeSmall -duplex $pd_printDuplex -graph $pd_printGraph \
	-inclib $pd_inclib -encoding $pd_encoding
  }
}

#############################################################################
#
# Dialog box for configuration of the printer list
#
namespace eval PrinterListDlg {
  variable printCommandEdit

  proc confirm {} {
    variable printCommandEdit
    global opts_printCommands
    global opts_printer

    set opts_printCommands [assocsetc $opts_printer $opts_printCommands $printCommandEdit]

    destroy .printerList
  }

  #############################################################################
  #
  # Post the dialog box for configuring the list of printers
  #
  proc post {pw} {
    global opts_printer
    variable printCommandEdit

    set w .printerList

    if { [catch {toplevel $w}] } {
      return
    }

    wm transient $w [gettoplevel $pw]
    wm resizable $w 0 0
    wm title $w "TKGate: Printer Configuration"
    wm geometry $w [offsetgeometry . 50 50 ]

    okcancel $w.okc -okcommand PrinterListDlg::confirm -cancelcommand { destroy .printerList }
    pack $w.okc -fill both -side bottom

    frame $w.main -bd 2 -relief raised

#    dialogImage $w.main.image -image [gifI printer.gif] -caption [m print.printcirc.cap] -width 175
#    pack $w.main.image -fill both -side left -pady 10

    set printCommandEdit [getPrintCommand $opts_printer]

    frame $w.main.pad1
    frame $w.main.pad2
    frame $w.main.conf
    label $w.main.conf.pname_l -text [m print.printer]
    label $w.main.conf.pname_e -text $PrintDlg::shortToLong($opts_printer)
    label $w.main.conf.pcmd_l -text [m print.prcmd]
    entry $w.main.conf.pcmd_e -textvariable PrinterListDlg::printCommandEdit -width 40 -bg white

    grid $w.main.conf.pname_l -row 0 -column 0 -padx 3 -pady 3 -sticky e
    grid $w.main.conf.pname_e -row 0 -column 1 -padx 3 -pady 3 -sticky w
    grid $w.main.conf.pcmd_l  -row 1 -column 0 -padx 3 -pady 3 -sticky e
    grid $w.main.conf.pcmd_e  -row 1 -column 1 -padx 3 -pady 3 -sticky w

    pack $w.main.pad1 -fill both -expand 1
    pack $w.main.conf
    pack $w.main.pad2 -fill both -expand 1

    pack $w.main -fill both -ipadx 15 -ipady 15

    dialogWait $w
  }
}

#############################################################################
#
# Dialog box for printing circuits
#
namespace eval PrintDlg {
  variable longToShort
  variable shortToLong

  proc fileChangeNotify args {
    global pd_file pd_traceFile
    global tkg_currentFile

    set pd_file       [replaceExtension $tkg_currentFile ".ps"]
    set pd_traceFile  [replaceExtension $tkg_currentFile "_trace.ps"]
  }

  #############################################################################
  #
  # Respond to change in printer page size dialog box.
  #
  proc setPaperSize {w psize} {
    global opts_printPgSize opts_printPgSizeName pageex_w

    set opts_printPgSize [paperNameToSize $opts_printPgSizeName]
    ScopePrintDlg::configPC

    prntUpdateExample $pageex_w
  }

  #############################################################################
  #
  # Paper selection dialog.  This is shared by both the "options" dialog print
  # page and the print dialog box.
  #
  proc paperSelect {w args} {
    global opts_paper paperSizeTable opts_printPgSize paperSizeTable
    global pageex_w

    labelframe $w [m print.pageset] -relief groove -bd 2
    frame $w.pad
    pack $w.pad -pady 3


    canvas $w.example -width 100 -height 100 -bd 2 -relief sunken -bg gray
    set pageex_w $w.example
    #  if { $where  == "right" } {
    pack $w.example -side right -padx 5 -pady 5
    #  } else {
    #    pack $w.example -side bottom -padx 5 -pady 5
    #  }
    prntUpdateExample $w.example

    frame $w.size

    label $w.size.l -text "[m print.papsz]:"

    set curSize [paperSizeToName $opts_printPgSize]

    Dropbox::new $w.size.mb -value $curSize -variable opts_printPgSizeName -width 25 \
	-command PrintDlg::setPaperSize
    foreach ps $paperSizeTable { 
      Dropbox::itemadd $w.size.mb [list [lindex $ps 1]]
    }

    pack $w.size.l $w.size.mb -side left -padx 5 -pady 5 -anchor w

    frame $w.o
    label $w.o.l -text "[m print.orient]: "
    radiobutton $w.o.p -text [m print.portrait] -variable opts_printPgOrient -value portrait \
	-command "ScopePrintDlg::configPC; prntUpdateExample $w.example"
    radiobutton $w.o.ls -text [m print.landscape] -variable opts_printPgOrient -value landscape \
	-command "ScopePrintDlg::configPC; prntUpdateExample $w.example"
    pack $w.o.l $w.o.p $w.o.ls  -side left -padx 5 -pady 5 -anchor w

    frame $w.dup
    checkbutton $w.dup.b -text [m print.2side] -variable opts_printDuplex -command "prntUpdateExample $w.example"
    pack  $w.dup.b -padx 5 -pady 5

    pack $w.size -anchor w -ipady 10
    pack $w.o -anchor w
    pack $w.dup -anchor w

    ScopePrintDlg::configPC
  }

  #############################################################################
  #
  # Style selection dialog.  This is shared by both the "options" dialog print
  # page and the print dialog box.
  #
  proc styleSelect {w r} {
    labelframe $w [m print.opts] -relief $r -bd 2

    frame $w.part
    radiobutton $w.part.scale -text [m print.scale] -variable opts_printStyle -value fit
    radiobutton $w.part.multi -text [m print.partition] -variable opts_printStyle -value part
    pack $w.part.scale $w.part.multi -anchor w

    checkbutton $w.idx -text [m print.incidx] -variable opts_printIndex
    checkbutton $w.graph -text [m print.incgraph] -variable opts_printGraph
    checkbutton $w.mrgsml -text [m print.4up] -variable opts_printMergeSmall

    frame $w.sp1
    frame $w.sp2

    pack $w.sp1 -anchor w -padx 5 -pady 5
    pack $w.part -anchor w -padx 5 
    pack $w.sp2 -anchor w -padx 5  -pady 10
    pack $w.idx -anchor w -padx 5 
    pack $w.graph -anchor w -padx 5 
    pack $w.mrgsml -anchor w -padx 5 
  }

  proc outputSelectNotify {lpr file} {
    global pd_isfile
    if { $pd_isfile } {
     #    ${lpr}_label configure -foreground dimgray
      $lpr.opts.l1 configure -foreground dimgray
      Dropbox::configure $lpr.opts.e1 -state disabled
      $lpr.opts.advanced configure -state disabled

      #    $lpr.opts.l2 configure -foreground dimgray
      #    $lpr.opts.e2 configure -foreground dimgray

      #    ${file}_label configure -foreground black
      $file.l configure -foreground black
      $file.e configure -foreground black -state normal
      $file.b configure -foreground black -state normal
      $file.epsf configure -foreground black -state normal
      focus $file.e
    } else {
      #    ${lpr}_label configure -foreground black
      $lpr.opts.l1 configure -foreground black
      Dropbox::configure $lpr.opts.e1 -state normal
      $lpr.opts.advanced configure -state normal
      #    $lpr.opts.l2 configure -foreground black
      #    $lpr.opts.e2 configure -foreground black



      #    ${file}_label configure -foreground dimgray
      $file.l configure -foreground dimgray
      $file.e configure -foreground dimgray -state disabled
      $file.b configure -foreground dimgray -state disabled
      $file.epsf configure -foreground dimgray -state disabled
      #    focus $lpr.e
    }
    tkg_prntEPSF
  }

  proc moduleSelect {w} {

    labelframe $w [m print.modulesel] -relief groove -bd 2
    frame $w.pad
    pack $w.pad -pady 3

    #  label $w.l  -text "[m print.prmod]:"
    frame $w.sel

    radiobutton $w.sel.all -text [m print.all] -value all -variable pd_select -command "tkg_prntModuleMode $w"
    radiobutton $w.sel.cur -text [m print.cur] -value cur -variable pd_select -command  "tkg_prntModuleMode $w"
    radiobutton $w.sel.use -text [m print.use] -value use -variable pd_select -command  "tkg_prntModuleMode $w"
    radiobutton $w.sel.sel -text [m print.sel] -value sel -variable pd_select -command "tkg_prntModuleMode $w"
    pack $w.sel.all  $w.sel.cur  $w.sel.use  $w.sel.sel -side left

    checkbutton $w.lib -text [m print.inclib] -variable pd_inclib

    frame $w.mods
    listbox $w.mods.lb -height 5 -yscrollcommand "$w.mods.vb set" -selectmode extended
    scrollbar $w.mods.vb -command "$w.mods.lb yview"
    pack $w.mods.lb $w.mods.vb -side left -fill y

    foreach e [BlockList::getallmodules] {
      $w.mods.lb insert end $e
    }

    #  pack $w.l -padx 5 -pady 5 -anchor w
    pack $w.sel  -padx 5 -pady 5 -anchor w
    pack $w.mods -padx 5 -pady 5
    pack $w.lib  -padx 5 -pady 5 -anchor w

    tkg_prntModuleMode $w

    helpon $w.sel.all [m ho.print.selall]
    helpon $w.sel.cur [m ho.print.selcur]
    helpon $w.sel.use [m ho.print.seluse]
    helpon $w.sel.sel [m ho.print.selsel]
    #  helpon $w.l [m ho.print.modlist]
  }

  #############################################################################
  #
  # Map a change in the long printer name to the short printer name
  #
  proc mapLPNChange args {
    global longPrinterName opts_printer   
    variable longToShort

    set opts_printer $longToShort($longPrinterName)
  }

  #############################################################################
  #
  # Printer selection dialog.  This is shared by both the "options" dialog print
  # page and the print dialog box.
  #
  proc lprSelect {w args} {
    global printers opts_printer
    variable longToShort
    variable shortToLong

    set radioframe 1
    set relief groove
    set fromoptions 0
    parseargs $args {-relief -radioframe -fromoptions}

    if {$radioframe} {
      radioframe $w [m print.printersel] -relief $relief -bd 2 -variable pd_isfile -value 0
      ${w}_label configure -command "PrintDlg::outputSelectNotify $w [winfo parent $w].file"
    } else {
      labelframe $w [m print.defaultprinter]
    }

    set printers [gat_getPrinterList]

    set defaultPrinter $opts_printer
    array unset longToShort
    array unset shortToLong
    foreach p $printers {
      set longToShort([lindex $p 1]) [lindex $p 0]
      set shortToLong([lindex $p 0]) [lindex $p 1]

      if {$defaultPrinter == ""} {
	set defaultPrinter [lindex $p 0]
      } 
    }

    frame $w.opts
    label $w.opts.l1  -text "[m print.prname]:"
    Dropbox::new $w.opts.e1 -value $shortToLong($defaultPrinter) -width 35 -variable longPrinterName

    foreach p $printers {
      Dropbox::itemadd $w.opts.e1 \"[lindex $p 1]\"
    }

    #  label $w.opts.l2  -text "[m print.prcmd]"
    #  entry $w.opts.e2 -textvariable opts_printCommand -bg white

    pack $w.opts.l1 $w.opts.e1 -pady 5 -padx 3 -side left -anchor w

#    if { $fromoptions } {
      frame $w.opts.pad
      pack $w.opts.pad -fill x -expand 1
      button $w.opts.advanced -text [m print.advanced]  -command "PrinterListDlg::post $w"
      pack $w.opts.advanced -pady 5 -padx 3 -side right -anchor e
#    }


    #  grid $w.opts.l1 -row 0 -column 0 -pady 5 -padx 3 -sticky e
    #  grid $w.opts.e1 -row 0 -column 1 -pady 5 -padx 3 -sticky ew
    #  grid $w.opts.l2 -row 1 -column 0 -pady 5 -padx 3 -sticky e
    #  grid $w.opts.e2 -row 1 -column 1 -pady 5 -padx 3 -sticky ew

    pack $w.opts -side left -pady 10 -padx 10 -fill x -expand 1
  }

  proc browseFile {which} {
    global pd_filter pd_filetypes pd_file pd_traceFile

    if { $which == "circuit" } {
      set fileNameVar pd_file
    } else {
      set fileNameVar pd_traceFile
    }

    set file [tk_getSaveFile -defaultextension $pd_filter -filetypes $pd_filetypes -parent .prntdlg]
    if { $file != "" } { 
      set $fileNameVar $file
      .prntdlg.left.file.e icursor end
      .prntdlg.left.file.e xview end
    }
  }

  #############################################################################
  #
  # File name selection
  #
  proc fileSelect {which w} {
    
    if { $which == "circuit" } {
      set fileNameVar pd_file
    } else {
      set fileNameVar pd_traceFile
    }

    radioframe $w [m print.filesel] -relief groove -bd 2 -variable pd_isfile -value 1
    ${w}_label configure -command "PrintDlg::outputSelectNotify [winfo parent $w].lpr $w"
    frame $w.pad
    pack $w.pad -pady 5
    label $w.l -text "[m print.filename]:"
    entry $w.e -textvariable $fileNameVar -width 30 -bg white
    button $w.b -text [m b.browse] -command "PrintDlg::browseFile $which"

    checkbutton $w.epsf -text [m print.epssave] -variable pd_epsf -command tkg_prntEPSF

    pack $w.epsf -side bottom -pady 5 -padx 5 -anchor w
    pack $w.l -pady 3 -padx 5 -anchor w
    pack $w.e -side left -padx 5 -fill x
    pack $w.b -side left -padx 5
  }


  #############################################################################
  #
  # Handler for tabs on the print dialog box.
  #
  proc tabs {w tab} {
    frame $w
    frame $w.main
    pack $w.main -side right -fill both -expand 1
    frame $w.main.pad -height 5
    pack $w.main.pad

    switch $tab {
      Output {
	#      tkg_prntOutSel $w.main.out $w.main.lpr $w.main.file
	PrintDlg::lprSelect $w.main.lpr -relief groove
	PrintDlg::fileSelect circuit $w.main.file
	PrintDlg::outputSelectNotify $w.main.lpr $w.main.file
	PrintDlg::paperSelect $w.main.paper groove

	#      pack $w.main.out -padx 5 -pady 5 -fill both
	pack $w.main.lpr -padx 5 -pady 5 -fill both
	pack $w.main.file -padx 5 -pady 5 -fill both
	pack $w.main.paper -padx 5 -pady 5 -fill both

	set explaination [m print.printcirc.out.exp]
      }
      Content {
	PrintDlg::moduleSelect $w.main.mod
	PrintDlg::styleSelect $w.main.style groove

	pack $w.main.mod -padx 5 -pady 5 -fill both
	pack $w.main.style -padx 5 -pady 5 -fill both

	set explaination [m print.printcirc.mod.exp]
      }
    }

    dialogImage $w.image -image [gifI printer.gif] -caption [m print.printcirc.cap] -width 175 -explaination $explaination
    pack $w.image -fill both -side left -pady 10

  }

  #############################################################################
  #
  # We have confirmed that we want to print.
  #
  proc confirm {} {
    global pd_ok 

    set pd_ok 1

    Option::dialogSave -optclass Print -prefix pd
    tkg_retrSelMods .prntdlg.right.mod

    destroy .prntdlg
  }



  #############################################################################
  #
  # Post the dialog box for printing a circuit
  #
  proc post {} {
    global pd_isfile pd_file pd_ok
    global tkg_currentFile tkg_displayFile

    set w .prntdlg

    if { [catch {toplevel $w}] } {
      return
    }

    wm transient $w .

    set p [string last "/" $pd_file]
    if { $p >= 0 } { set pd_file [string range $pd_file [expr $p + 1] end]}

    set pd_ok 0

    wm resizable $w 0 0
    wm title $w "TKGate: Print"
    wm geometry $w [offsetgeometry . 50 50 ]

    Option::dialogLoad -optclass Print

    set labels [list [m print.tab.output] [m print.tab.content]]
    frame $w.main
    TabBox::new $w.main.tab -width 650 -height 400 -tabwidth 95 -tabs {Output Content} \
	-command PrintDlg::tabs -tablabels $labels

    okcancel $w.okc -okcommand PrintDlg::confirm -cancelcommand { destroy .prntdlg } -oktext [m print.ok]
    pack $w.okc -fill both -side bottom
    pack $w.main -fill both
    pack $w.main.tab -fill both

    dialogWait $w

    if {$pd_ok} {
      global pd_file pd_paper pd_printPgOrient pd_printStyle pd_select pd_selectList
      global pd_epsf pd_printIndex pd_printMergeSmall pd_printDuplex pd_inclib pd_printGraph pd_encoding
      global pd_printPgSize

      if {$pd_isfile} {
	gat_print -file $pd_file -paper $pd_printPgSize -orient $pd_printPgOrient \
	    -style $pd_printStyle -select $pd_select -modlist $pd_selectList -epsf $pd_epsf \
	    -index $pd_printIndex -merge $pd_printMergeSmall -duplex $pd_printDuplex \
	    -graph $pd_printGraph -inclib $pd_inclib -encoding $pd_encoding
      } { 
	set printer [getPrintCommand]
	gat_print -printer $printer -paper $pd_printPgSize -orient $pd_printPgOrient \
	    -style $pd_printStyle -select $pd_select -modlist $pd_selectList -epsf $pd_epsf \
	    -index $pd_printIndex -merge $pd_printMergeSmall -duplex $pd_printDuplex \
	    -graph $pd_printGraph -inclib $pd_inclib -encoding $pd_encoding
      }
    }
  }
}

#############################################################################

namespace eval ScopePrintDlg {

  #############################################################################
  #
  # Update page count if doing a trace print.
  #
  proc configPC args {
    global prs_start prs_end prs_range prs_isFull prs_numepochs prs_scale pd_paper
    global page_estimate pd_printPgOrient opts_printPgSize opts_printPgOrient

    if { $prs_isFull } {
      set start 0
      set end [lindex $prs_range 2]
    } {
      set start $prs_start
      set end $prs_end
    }

    set page_estimate [gat_tracePageEst -orient $opts_printPgOrient -start $start -end $end -scale $prs_scale -paper $opts_printPgSize]
  }



  proc rangeScaleNotify {w} {
    global prs_isFull

    if { $prs_isFull } {
      $w.g.sl configure -foreground dimgray
      $w.g.el configure -foreground dimgray
      $w.g.se configure -foreground dimgray -state disabled
      $w.g.ee configure -foreground dimgray -state disabled
    } {
      $w.g.sl configure -foreground black
      $w.g.el configure -foreground black
      $w.g.se configure -foreground black -state normal
      $w.g.ee configure -foreground black -state normal
    }

    ScopePrintDlg::configPC
  }

  proc loadRange {} {
    global prs_start prs_end prs_range prs_isFull prs_traceEnd prs_scale

    set prs_range [gat_getTraceData]
    set prs_start [lindex $prs_range 0]
    set prs_end [lindex $prs_range 1]
    set prs_traceEnd [lindex $prs_range 2]
    set prs_scale 70
  }

  proc rangeSelect {w} {
    global prs_start prs_end prs_range prs_isFull prs_traceEnd

    labelframe $w [m print.range] -relief groove -bd 2
    frame $w.pad
    pack $w.pad -pady 5

    if { $prs_start == 0 && $prs_end == $prs_traceEnd} {
      set prs_isFull 1
    } else {
      set prs_isFull 0
    }

    radiobutton $w.full -text [m print.fulltr] -variable prs_isFull -value 1 -command "ScopePrintDlg::rangeScaleNotify $w"
    radiobutton $w.part -text [m print.parttr] -variable prs_isFull -value 0 -command "ScopePrintDlg::rangeScaleNotify $w"

    frame $w.g
    label $w.g.sl -text [m print.start]
    label $w.g.el -text [m print.end]
    entry $w.g.se -textvariable prs_start -bg white
    entry $w.g.ee -textvariable prs_end -bg white
    grid $w.g.sl -row 0 -column 0 -sticky e -padx 5 -pady 5
    grid $w.g.se -row 0 -column 1 -padx 5 -pady 5
    grid $w.g.el -row 1 -column 0 -sticky e -padx 5 -pady 5
    grid $w.g.ee -row 1 -column 1 -padx 5 -pady 5

    pack $w.full -padx 5 -pady 2 -anchor w
    pack $w.part -padx 5 -pady 2 -anchor w
    pack $w.g -padx 5 -pady 5

    ScopePrintDlg::rangeScaleNotify $w

    helpon $w.full [m ho.print.fulltrace]
    helpon $w.part [m ho.print.parttrace]
    helpon $w.g.sl [m ho.print.parttracestart]
    helpon $w.g.el [m ho.print.parttraceend]
  }


  proc scaleSelect {w} {
    global page_estimate

    set sc_max 1000
    set sc_min 10

    labelframe $w [m print.scaleselect] -relief groove -bd 2
    frame $w.pad
    pack $w.pad -pady 5

    scale $w.s -label [m print.epcm] -from $sc_max -to $sc_min -length 200 -orient horizontal -variable prs_scale -command ScopePrintDlg::configPC

    label $w.l -text "[m print.estpg]: "

    set page_estimate 0
    label $w.pc -textvariable page_estimate

    pack $w.s -padx 5 -pady 5
    pack $w.l $w.pc -side left -padx 5 -pady 5
  }

  proc confirm {} {
    global pd_ok

    set pd_ok 1
    destroy .prntdlg
  }

  proc tabs {w tab} {
    frame $w
    frame $w.main
    pack $w.main -side right -fill both -expand 1
    frame $w.main.pad -height 5
    pack $w.main.pad

    switch $tab {
      Output {
	PrintDlg::lprSelect $w.main.lpr -relief groove
	PrintDlg::fileSelect trace $w.main.file
	PrintDlg::outputSelectNotify $w.main.lpr $w.main.file
	PrintDlg::paperSelect $w.main.paper groove

	pack $w.main.lpr -padx 5 -pady 5 -fill both
	pack $w.main.file -padx 5 -pady 5 -fill both
	pack $w.main.paper -padx 5 -pady 5 -fill both

	set explaination [m print.printcirc.out.exp]
      }
      Content {
	ScopePrintDlg::rangeSelect $w.main.range
	ScopePrintDlg::scaleSelect $w.main.scale

	pack $w.main.range -padx 5 -pady 5 -fill both
	pack $w.main.scale -padx 5 -pady 5 -fill both

	set explaination [m print.printtrace.trace.exp]
      }
    }

    dialogImage $w.image -image [gifI printer.gif] -caption [m print.printtrace.cap] -width 175 -explaination $explaination
    pack $w.image -fill both -side left -pady 10
  }

  #
  # Dialog box for scope traces
  #
  proc post {} {
    global pd_isfile pd_traceFile pd_ok
    global tkg_currentFile tkg_displayFile
    global prs_start prs_end prs_scale

    if { ![tkg_simCheck] } return

    loadRange

    set w .prntdlg

    if { [catch {toplevel $w}] } {
      return
    }

    wm transient $w .scope

    set pd_traceFile  [replaceExtension $tkg_currentFile "_trace.ps"]
    set p [string last "/" $pd_traceFile]
    if { $p >= 0 } { set pd_traceFile [string range $pd_traceFile [expr $p + 1] end]}

    set pd_ok 0

    wm resizable $w 0 0
    wm title $w "TKGate: Scope Print"
    wm geometry $w [offsetgeometry . 50 50 ]

    Option::dialogLoad -optclass Print

    set labels [list [m print.tab.output] [m print.tab.content]]
    frame $w.main
    TabBox::new $w.main.tab -width 650 -height 350 -tabwidth 95 -tabs {Output Content} \
	-command ScopePrintDlg::tabs -tablabels $labels

    okcancel $w.okc -okcommand ScopePrintDlg::confirm -cancelcommand { destroy .prntdlg } -oktext [m print.ok]
    pack $w.okc -fill both -side bottom
    pack $w.main -fill both
    pack $w.main.tab -fill both

    dialogWait $w
    Option::dialogSave -optclass Print -prefix pd

    if {$pd_ok} {
      global pd_traceFile pd_paper pd_printPgOrient pd_epsf pd_printDuplex page_estimate pd_printPgSize

      if { $page_estimate > 40 } {
	if {[tk_messageBox -type yesno -default no -message [m err.manypages]] != "yes"} {
	  return
	}
      }

      if {$pd_isfile} {
	gat_tracePrint -file $pd_traceFile -paper $pd_printPgSize -orient $pd_printPgOrient -epsf $pd_epsf \
	    -duplex $pd_printDuplex -scale $prs_scale -start $prs_start -end $prs_end
      } { 
	set printer [getPrintCommand]
	gat_tracePrint -printer $printer -paper $pd_printPgSize -orient $pd_printPgOrient -epsf $pd_epsf \
	    -duplex $pd_printDuplex -scale $prs_scale -start $prs_start -end $prs_end
      }
    }
  }
}